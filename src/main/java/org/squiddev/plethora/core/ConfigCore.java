package org.squiddev.plethora.core;

import net.minecraftforge.common.config.ConfigCategory;
import net.minecraftforge.common.config.Configuration;
import org.squiddev.configgen.*;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;

@Config(languagePrefix = "gui.config.plethora.")
public final class ConfigCore {
	public static Configuration configuration;

	public static ConfigCategory baseCosts;

	private ConfigCore() {
	}

	public static void init(File file) {
		ConfigCoreForgeLoader.init(file);
		configuration = ConfigCoreForgeLoader.getConfiguration();

		baseCosts = configuration.getCategory("basecosts");
	}

	public static void sync() {
		ConfigCoreForgeLoader.sync();
	}

	/**
	 * Some methods have a particular cost: they
	 * consume a set amount of energy from their owner.
	 * This level regenerates over time.
	 *
	 * *Note:* These values only apply to the default handler.
	 * Other mods may add custom handlers.
	 */
	public static final class CostSystem {
		/**
		 * The energy level all systems start at
		 */
		@DefaultDouble(100)
		@Range(min = 0)
		public static double initial;

		/**
		 * The amount of energy regenerated each tick
		 */
		@DefaultDouble(10)
		@Range(min = 0)
		public static double regen;

		/**
		 * The maximum energy level an item can have
		 */
		@DefaultDouble(100)
		@Range(min = 0)
		public static double limit;

		/**
		 * Allow costs to go into the negative.
		 * Methods will fail when there is negative energy.
		 * This allows you to use costs higher than the allocated
		 * buffer and so have a more traditional rate-limiting system.
		 */
		@DefaultBoolean(false)
		public static boolean allowNegative;

		/**
		 * Wait for the system to get sufficient energy instead of throwing
		 * an error.
		 */
		@DefaultBoolean(true)
		public static boolean awaitRegen;

		private CostSystem() {
		}
	}

	/**
	 * Blacklist various providers
	 */
	public static final class Blacklist {
		/**
		 * List of provider classes, packages or methods which are blacklisted.
		 * This will blacklist all converters, methods and transfer and meta providers
		 * matching a pattern.
		 *
		 * This only applies to classes registered through annotations and does not blacklist
		 * method builders.
		 *
		 * Valid forms:
		 * - "foo.bar" - All classes in package (note trailing period).
		 * - "foo.bar.Provider" - This class, all its members and nested classes
		 * - "foo.bar.Provider#method" - A particular method with a name
		 */
		public static ArrayList<String> blacklistProviders;

		/**
		 * List of tile entity classes or packages which will not be wrapped
		 * as peripherals. For example use "net.minecraft." to disable wrapping
		 * any vanilla peripheral. This does not blacklist subclasses.
		 */
		public static ArrayList<String> blacklistTileEntities;

		/**
		 * List of mods to block.
		 * IMPORTANT: This does not block wrapping a mod's peripherals, just disables
		 * custom mod specific integration.
		 */
		public static HashSet<String> blacklistMods;

		/**
		 * List of modules to blacklist.
		 */
		public static HashSet<String> blacklistModules;

		/**
		 * List of modules to blacklist from being mounted on a turtle.
		 *
		 * This includes all blacklisted modules.
		 */
		public static HashSet<String> blacklistModulesTurtle;

		/**
		 * List of modules to blacklist from being mounted on a pocket computer.
		 *
		 * This includes all blacklisted modules.
		 */
		public static HashSet<String> blacklistModulesPocket;

		/**
		 * List of modules to blacklist from being mounted on a minecart or other vehicle.
		 *
		 * This includes all blacklisted modules.
		 */
		public static HashSet<String> blacklistModulesVehicle;

		/**
		 * List of modules to blacklist from being mounted from a tile.
		 *
		 * For instance, the note block tile exposes the minecraft:noteblock module, allowing
		 * you to use that module from the tile's peripheral, rather than through a manipulator.
		 *
		 * This includes all blacklisted modules.
		 */
		public static HashSet<String> blacklistModulesTile;

		private Blacklist() {
		}
	}

	/**
	 * Various options for debugging and testing this mod
	 */
	public static final class Testing {
		/**
		 * Enable strict loading mode. This will ensure non-lazy
		 * loading of methods, and crash when an error is encountered
		 * rather than just logging.
		 */
		@RequiresRestart
		@DefaultBoolean(false)
		public static boolean strict;

		/**
		 * Verify generated bytecode for generated methods.
		 * Only needed if you're developing new method builders.
		 */
		@DefaultBoolean(false)
		public static boolean bytecodeVerify;

		private Testing() {
		}
	}

	/**
	 * The base costs for all methods.
	 */
	public static class BaseCosts {
	}
}
